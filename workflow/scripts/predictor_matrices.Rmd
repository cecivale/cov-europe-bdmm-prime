---
title: "GLM Predictor Matrices"
subtitle: "Analyses Europe6 and Europe7"
author: "Cecilia Valenzuela"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  beamer_presentation:
    theme: "Pittsburgh"
    colortheme: "dove"
    fonttheme: "structurebold"
    highlight: pygments
classoption: "aspectratio=169"
fontsize: 8pt
tables: yes
---
```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r, echo = FALSE, results ='hide', message = FALSE}
library(knitr)
library(wpp2019)
library(tidyverse)
library(readr)
library(ggsci)
library(scales)
library(countrycode)
library(geosphere)
library(maps)
library(sf)
source("./scripts/utils.R")
source("./scripts/flight_data.R")
```

## Description

Generation of the predictor matrices for the GLM model from different sources 
of information: 

- Eurostats, European data and statistics, transport data: <https://ec.europa.eu/eurostat/web/transport/data/database>
- United Nations Population Division, World Population Prospects 2019: R library `wpp2019, data(pop)`
- World map from the Natural Earth project (2013), loaded with R library `maps`.

## GLM Model

We define the migration rates $m_{ij}^{e}$ from deme $i$ to deme $j$ in epoch $e$ as a log linear function of a set of predictors $\boldsymbol{X}$, log transformed and scaled, such that

$$
m_{ij}^{e} = c \exp(\beta_{pas} \delta_{pas} x_{ij.pas}^e + \beta_{pop} \delta_{pop }x_{ij.pop} + \beta_{dist} \delta_{dist}x_{ij.dist})
$$

where $\boldsymbol{\beta}$ are the coefficients for the predictors that can be between $-\infty$ and $\infty$ (prior  $\mathcal{N}(0,4)$) and $\boldsymbol{\delta}$ are the indicators that can be 0 or 1 and denote if a predictor contributes at all. 

## Daily flight passengers

Passengers carried data from Eurostats. Reported _departures_ values are taken for European countries (recommendation from Eurostats to avoid duplicates). For China, arrivals and departures values are considered.

- **Epoch 1:** December 2019 - January 2020 (Wuhan lockdown 23 Jan)
- **Epoch 2:** February 2020 
- **Epoch 3:** March 2020

\tiny
```{r, echo = FALSE, message = FALSE, warning = FALSE}
demes <- c(China = "CN", France = "FR", Germany = "DE", Italy = "IT", OtherEuropean = "OE", Spain = "ES")

# These datasets are dowload from eurostats 
intraUE_data <- "./data/avia_paincc.tsv"
extraUE_data <- "./data/avia_paexcc.tsv"

flight_df <- get_flightData(intraUE_data, extraUE_data, countries = demes) 

flight_df_3e <- flight_df %>%
  filter((MONTH %in% 1:3 & YEAR == 2020) | (MONTH == 12 & YEAR == 2019)) %>%
  mutate(EPOCH = case_when(
    MONTH == 2 ~ 2,
    MONTH == 3 ~ 3,
    TRUE ~ 1),
    PRED = 1) %>%
  rename(SRC = GEO, DEST = PARTNER) %>%
  group_by(SRC, DEST, EPOCH, PRED) %>%
  summarise(N = n(),
         EVALUE = sum(DVALUE/N)) %>%
  ungroup %>%
  # Transformations
  mutate(LVALUE = log(EVALUE + 1),
         SLVALUE = scale(LVALUE)) %>%
  arrange(EPOCH, factor(SRC, levels = demes), factor(DEST, levels = demes))

#write(slv_flightMatrix_3e, "files/flight_matrix_3e.csv", sep = ",")
```

```{r, echo = FALSE}
flight_matrices <- lapply(1:3, function (i) {
  flight_df_3e %>%
  filter(EPOCH == i) %>%
  select(SRC, DEST, SLVALUE) %>%
  pivot_wider(names_from = "DEST", values_from = "SLVALUE") %>%
  mutate_if(is.numeric, ~round(.,2)) %>%
  column_to_rownames("SRC") %>%
  select(all_of(unname(demes)))
})

knitr::kable(flight_matrices, booktabs = TRUE, caption = "Flight passengers between demes, epochs 1-3")
```

## Daily flight passengers

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 3}
set_plotopts()
dcolors <- pal_npg("nrc")(10)[c(1:5,9)]
dcolors <- dcolors[1:length(demes)]
names(dcolors) <- demes[sort(labels(demes))]

# Fligh data plot
ggplot(flight_df_3e, aes(x = EPOCH, y = EVALUE, color = DEST)) +
  geom_line() +
  geom_point(size = 1) +
  scale_y_log10(labels = trans_format("log10", math_format(10^.x)), breaks = trans_breaks('log10', function(x) 10^x)) +
  scale_x_continuous(breaks = c(1, 2, 3), labels = c("E1", "E2", "E3")) +
  facet_grid(~SRC) +
  xlab("Epoch") +
  ylab("# Daily Flight Passengers") + 
  #theme(axis.title.x = element_blank()) + 
  scale_color_manual(values = dcolors, name = "Destination")
```


## Population counts

```{r, echo=FALSE}
data(pop)
population <- pop %>% filter(name %in% labels(demes)) %>% select(name, "2020") 
pop_eu_demes <- population %>% filter(name != "China") %>% summarise(s = sum(`2020`)) %>% pull(s)
pop_eu_total <- pop %>% filter(name == "Europe") %>% pull("2020")
population <- population %>%
  tibble::add_row(name = "OtherEuropean", `2020` = pop_eu_total - pop_eu_demes) %>%
  arrange(name) %>%
  rename(POP = 2) %>%
  mutate(SLVALUE = scale(log(POP)))
pop_df <- population %>%
  mutate(n = 6, SRC = demes) %>%
  uncount(n) %>%
  mutate(DEST = rep(demes, 6),
         POP = ifelse(SRC == DEST, NA, POP),
         SLVALUE = ifelse(SRC == DEST, NA, SLVALUE)) %>%
  select(-name) %>%
  filter(!is.na(POP))
pop_df_3e <- bind_rows(replicate(3, pop_df %>% mutate(PRED = 2), simplify = FALSE)) %>% 
  mutate(EPOCH = rep(1:3, each = 30, length = 90)) %>%
  bind_rows(bind_rows(replicate(3, pop_df %>% 
                        arrange(factor(DEST, levels = demes),
                                factor(SRC, levels = demes)) %>%
                          mutate(TEMP = SRC,
                                 SRC = DEST,
                                 DEST = TEMP,
                                 PRED = 3),
                      simplify = FALSE)) %>%
  mutate(EPOCH = rep(1:3, each = 30, length = 90)))
```

Population counts from World Population Prospects 2019, United Nations Population Division,  `wpp2019` R library: **China** - `r population[1,2] * 1e3`, **France** - `r population[2,2] * 1e3`, **Germany** - `r population[3,2] * 1e3`, **Italy** - `r population[4,2] * 1e3`, **Other European** - `r population[5,2] * 1e3` and **Spain** - `r population[6,2] * 1e3`.

A predictor matrix for source population and a predictor matrix for destination population are generated, log transformed and standardized. Constant across epochs.

\tiny
```{r, echo=FALSE}
pop_matrices <- lapply(c("DEST", "SRC"), function (x) {
  pop_df %>%
  select(-POP) %>%
  pivot_wider(names_from = all_of(x), values_from = "SLVALUE") %>%
  mutate_if(is.numeric, ~round(., 2)) %>%
  mutate_at(1, ~factor(., levels = demes)) %>%
  arrange_at(1) %>%
  select(1, all_of(unname(demes)))
})

knitr::kable(pop_matrices, booktabs = TRUE, caption = "Population counts source (left) and destination (right)")
```

\normalsize
Other European population count is computed as the difference between the Europe population and the sum of the populations from France, Germany, Italy and Spain.


## Geographical distance

```{r, echo = FALSE, warning = FALSE, message = FALSE}
map <- st_as_sf(map("world", plot = FALSE, fill = TRUE)) %>%
  mutate(country = ifelse(ID == "UK", "United Kingdom", as.character(ID)),
         continent = countrycode(sourcevar = country,
                             origin = "country.name",
                             destination = "continent")) %>%
  filter(country %in% labels(demes) | continent == "Europe") %>%
  mutate(deme = case_when(
    country %in% labels(demes) ~ country,
    TRUE ~ "OtherEuropean"))
map <- cbind(map, st_coordinates(st_centroid(map))) %>%
  rename(longitude = X, latitude = Y) %>%
  mutate(deme = demes[deme])

centroids <- data.frame(map) %>%
  select(country, deme, longitude, latitude)

dist_df <- centroids %>%
  full_join(centroids, by = character())
dist_df <- dist_df%>%
  mutate(DIST = distHaversine(select(dist_df, longitude.x, latitude.x),
                              select(dist_df, longitude.y, latitude.y))) %>%
  group_by(deme.x, deme.y) %>%
  summarise(DIST = mean(DIST), .groups = "drop") %>%
  filter(deme.x != deme.y) %>%
  rename(SRC = deme.x, DEST = deme.y) %>% 
  mutate(SLVALUE = scale(log(DIST))) %>%
  arrange(factor(SRC, levels = demes), factor(DEST, levels = demes))
dist_df_3e <- bind_rows(replicate(3, dist_df, simplify = FALSE)) %>%
  mutate(EPOCH = rep(1:3, each = 30, length = 90), PRED = 4)
```

Great circle pairwise distance between centroids of each country. Centroids are computed  from the Natural Earth project (the 1:50m resolution version) world map 2013. Constant across epochs. Symmetric.

\tiny
```{r, echo = FALSE}
dist_matrix <- dist_df %>%
  select(-DIST) %>%
  pivot_wider(names_from = "DEST", values_from = "SLVALUE") %>%
  mutate_if(is.numeric, ~round(., 2)) %>%
  column_to_rownames("SRC") %>%
  select(all_of(unname(demes)))

knitr::kable(dist_matrix, booktabs = TRUE, caption = "Great circle pairwise distance between countries geographic centroid.")
```

\normalsize
The distance from one deme to the Other European deme is the average distance between the deme centroid and all the Other European countries centroids.

## Geographical distance

```{r, echo = FALSE, message =  FALSE, fig.align="center"}

ggplot() +
    geom_sf(data = map, aes(fill = deme), alpha = 0.7) + 
    geom_point(data = map %>% filter(country %in% labels(demes)), aes(x = longitude, y = latitude), shape = 4, size = 2) +
    coord_sf(xlim = c(-15, 120), ylim = c(25, 60), expand = FALSE) +
  scale_fill_manual(values = dcolors, na.value = "grey") +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())
```

Map of Europe and part of Asia showing the demes included in the analysis (in color). The X represents the centroid of each deme. The centroids of each European country fromm the Other European deme are not drawed.

<!-- Other distance ptions: -->
<!-- Average pairwaise distance between airports - considers that only flight transportation matters, more work -->
<!-- Distance taking into account population distribution inside the country. CEPPI dataset -->
<!-- Minimum distance. -->

## Covariate list BEAST BDMM-Prime

The three predictors are saved in the following order: **Flight data, population count source, population count destination and geographical distance.** 

Each of the predictor is composed of three matrices, one per epoch, with the first matrix being the most recent epoch, e.g. the first 30 values correponds to the fligh data for March.

Diagonal values are skipped.

Therefore the final size of the covariate list is of dimension $(30 \cdot 3) \cdot 4 = 360$.

```{r, echo = FALSE}
pred_3e <- bind_rows(flight_df_3e, pop_df_3e) %>%
  bind_rows(dist_df_3e) %>%
  arrange(PRED, desc(EPOCH), factor(SRC, levels = demes), factor(DEST, levels = demes)) %>%
  select(PRED, EPOCH, SRC, DEST, SLVALUE)
  
if (nrow(pred_3e) != 360) warning("Something went wrong, the size of the combined predictors is ", nrow(pred_3e))

mpred_3e <- as.data.frame(matrix(pred_3e %>% pull(SLVALUE), ncol = 5, byrow = TRUE))
write_csv(mpred_3e, "./files/covariates_4p_3e.csv", col_names = FALSE)
```

\

Covariate list saved as `files/covariates_4p_3e.csv`

